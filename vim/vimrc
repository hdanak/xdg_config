
" Perl utility functions
perl << EOF

sub say { VIM::Msg(join '', @_) }
sub vi { (VIM::Eval(shift))[1] }
sub ex { (VIM::DoCommand(shift))[1] }

sub vi_opt {
    vi('&'.shift)
}

use Scalar::Util qw(looks_like_number);

sub vi_from_pl {
    my ($data) = @_;
    if (@_ > 1) {
        return '[ ' . join(', ', map {vi_from_pl($_)} @_) . ' ]'
    } elsif ('ARRAY' eq ref $data) {
        return vi_from_pl(@$data)
    } elsif ('HASH' eq ref $data) {
        return '{ ' . join(', ', map {
            vi_from_pl($_) . ": " . vi_from_pl($data->{$_})
        } keys %$data) . ' }'
    } elsif (looks_like_number($data)) {
        return $data
    } else {
        $data =~ s/'/\\'/g;
        return "'" . $data . "'"
    }
}

sub vi_to_pl {
    map {
        my @parts = split "\n";
        @parts > 1
        ?   map { vi_to_pl($_) } @parts
        :   $_ eq '' ? () : $_
    } @_
}

sub vi_raw_call {
    my @retval = *{shift()}->(vi_to_pl(vi("a:000")));
    ex("return ". vi_from_pl(@retval)) if @retval;
}

sub vi_func (*&) {
    my ($fname, $fsub) = @_;
    *{$fname} = $fsub;
    ex qq{
:       function! $fname(...)
:           perl vi_raw_call('$fname')
:       endfunction
    }
}

## Utility functions defined in both VIM and Perl

vi_func CharAt, sub {
    my ($line, $column, $char) = @_;
    my $text = TextAtLine($line);
    if (defined $char) {
        substr $text, $column, 1, $char;
        TextAtLine($line, $text);
        return $char
    } else {
        return substr($text, $column, 1)
    }
};
vi_func DeleteCharAt, sub {
    CharAt($_[0], $_[1], '')
};
vi_func TextAtLine, sub {
    my ($line, $text) = @_;
    if (defined $text) {
        $curbuf->Set($line, $text);
    }
    return $curbuf->Get($line);
};
vi_func DeleteTextAtLine, sub {
    TextAtLine($_[0], '')
};
vi_func Cursor, sub {
    $curwin->Cursor(@_) if @_;
    return $curwin->Cursor()
};
vi_func CursorLine, sub {
    my ($new_line) = @_;
    my ($line, $column) = Cursor();
    Cursor($line=$new_line, $column) if @_;
    return $line
};
vi_func CursorColumn, sub {
    my ($new_column) = @_;
    my ($line, $column) = Cursor();
    Cursor($line, $column=$new_column) if @_;
    return $column
};
EOF

perl << EOF
vi_func NextTabstop, sub {
    my $colnum = CursorColumn();
    my $ts = vi_opt 'tabstop';
    ( CharAt(Cursor()) eq "\t"
    ? $colnum + 1
    : $colnum + $ts - $colnum % $ts )
};
vi_func PrevTabstop, sub {
    my $colnum = CursorColumn();
    my $ts = vi_opt 'tabstop';
    ( CharAt(Cursor()) eq "\t"
    ? $colnum - 1
    : $colnum - 1 - ($colnum - 1) % $ts )
}
EOF

map <silent> <tab> :call CursorColumn(NextTabstop())<CR>
map <silent> <S-tab> :call CursorColumn(PrevTabstop())<CR>
map <silent> <Esc>l :call CursorColumn(NextTabstop())<CR>
map <silent> <Esc>h :call CursorColumn(PrevTabstop())<CR>

perl << EOF
vi_func RemoveLastTab, sub {
    my ($line, $column) = Cursor();
    if (CharAt($line, $column) eq "\t") {
        DeleteCharAt($line, $column);
        CursorColumn($column - 1);
    } else {
        my $ts = vi_opt 'tabstop';
        $column = PrevTabstop();
        my $text = TextAtLine($line);
        my $snip = substr $text, $column, $ts;
        $snip =~ s/\s+$//;
        substr $text, $column, $ts, $snip;
        TextAtLine($line, $text);
        CursorColumn($column + length($snip));
    }
}
EOF

imap <S-tab> <C-o>:call RemoveLastTab()<CR>

nmap j gj
nmap k gk

nmap <C-h> <C-w>h
nmap <C-l> <C-w>l
nmap <C-j> <C-w>j
nmap <C-k> <C-w>k

nmap <Esc>OD gT
nmap <Esc>OC gt
nmap <Esc>OB <C-e>
nmap <Esc>OA <C-y>

nmap <Esc>j 4j
nmap <Esc>k 4k

let $PAGER=''
runtime ftplugin/man.vim
nmap K :Man <cword><CR>

function! FoldText()
    let foldline = matchstr(getline(v:foldstart), '^\s*\zs.*\ze$') . ' '
    let nextline = getline(nextnonblank(v:foldstart + 1))
    if foldline =~ '^\s*"""'
        let foldline = foldline . matchstr(nextline, '^\s*\zs.*\ze$')
    elseif foldline =~ '^\s\+"[^"]\+"$'
        let foldline = foldline . matchstr(nextline, '"\zs.*\ze"')
    endif
    let size = 1 + v:foldend - v:foldstart
    return "+ " . size . " lines:  " . foldline
endfunction

set foldmethod=indent
set foldminlines=3
set foldtext=FoldText()
set foldlevelstart=1

set formatoptions=croqln1 "a -- makes it reflow comments
let &showbreak=repeat(' ', winwidth(0)/3) . ' ..'
set linebreak

nmap Q gq}<C-o>
nmap S :w<CR>

set spell
set hlsearch
nnoremap <silent> <Leader><Leader> :nohlsearch<CR>

hi SpellBad         cterm=underline ctermfg=red         ctermbg=black
hi SpellCap         cterm=underline ctermfg=cyan        ctermbg=black
hi Search           cterm=bold      ctermfg=darkblue    ctermbg=grey
hi Folded                           ctermfg=grey        ctermbg=NONE
hi FoldColumn                       ctermfg=grey        ctermbg=NONE
hi VertSplit                        ctermfg=black       ctermbg=grey
hi StatusLine       cterm=bold      ctermfg=darkgrey    ctermbg=grey
hi StatusLineNC     cterm=NONE      ctermfg=grey        ctermbg=grey
hi ColorColumn      cterm=underline ctermfg=darkgrey    ctermbg=black
hi LineNr           cterm=NONE      ctermfg=brown       ctermbg=black
hi ExtraWhitespace                                      ctermbg=red

match ExtraWhitespace /\s\+$\| \+\ze\t/

set number
nmap <silent> <F3> :exec &number ? "set relativenumber" : "set number"<CR>

set textwidth=78
set colorcolumn=+2

set background=dark
set tabstop=4 sts=4 sw=4 et
filetype plugin indent on
syntax on
set nomodeline

noremap <silent> <Leader>vs :<C-u>let @z=&so<CR>:set so=0 noscb<CR>:bo vs<CR>Ljzt:setl scb<CR><C-w>p:setl scb<CR>:let &so=@z<CR>
